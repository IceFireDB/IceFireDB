<!doctype html><html><head><title>IceGiant WhitePaper::IceGiant:The Decentralized NoSQL Protocol</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=img/favicon.ico type=image/x-icon><link rel=stylesheet type=text/css href=/icegiant_whitepaper/sass/master.min.css><link rel=stylesheet type=text/css href=/icegiant_whitepaper/sass/topbar_footer.min.css><link href="https://fonts.googleapis.com/css?family=Cutive+Mono&display=swap" type=text/css rel=stylesheet><link rel=stylesheet type=text/css href=/icegiant_whitepaper/sass/article_page.min.css><link rel=stylesheet type=text/css href=/icegiant_whitepaper/sass/article.min.css></head><body><div class=container><div class=topbar><span class=tb-title><a href=https://www.icefiredb.xyz/icegiant_whitepaper/>IceGiant WhitePaper</a></span><ul class=tb-navbar><li><a href=/icegiant_whitepaper>IceGiant:The Decentralized NoSQL Protocol</a></li></ul></div><div class=info-panel>&nbsp;</div><div class=article-div><h1>IceGiant:The Decentralized NoSQL Protocol</h1><article><ul><li><a href=#abstract>Abstract</a></li><li><a href=#1-introduce>1. Introduce</a><ul><li><a href=#11-motivation>1.1 Motivation</a></li><li><a href=#12-glossary-of-terms>1.2 Glossary of Terms</a></li></ul></li><li><a href=#2system-composition>2.System composition</a><ul><li><a href=#21-network-structure>2.1 Network structure</a></li><li><a href=#22-storage-mechanism>2.2 Storage mechanism</a></li><li><a href=#22-smart-contracts>2.2 Smart contracts</a></li><li><a href=#23-query-structure>2.3 Query structure</a></li></ul></li><li><a href=#3node-architectur>3.Node architectur</a><ul><li><a href=#31-reverse-proxy>3.1 Reverse proxy</a></li><li><a href=#32-icegiant-synchronize>3.2 IceGiant synchronize</a></li><li><a href=#33-nosql-storage-engine>3.3 NoSQL storage engine</a></li><li><a href=#34-advanced-request-handler>3.4 Advanced request handler</a></li></ul></li><li><a href=#4-smart-contracts>4. Smart contracts</a><ul><li><a href=#41-transaction-structure>4.1 Transaction Structure</a></li><li><a href=#42-contract-interaction>4.2 Contract interaction</a></li></ul></li><li><a href=#5index-tracking-block-metadata>5.Index: tracking block metadata</a><ul><li><a href=#51-ifdb-token>5.1 $IFDB token</a></li><li><a href=#52-sales-verification-node-program>5.2 Sales Verification Node Program</a></li><li><a href=#53-peer-verifier>5.3 Peer verifier</a></li></ul></li><li><a href=#6funding-pool-multi-chain-support>6.Funding pool: multi-chain support</a><ul><li><a href=#61-evm-multi-chain-fund-pool>6.1 EVM multi-chain fund pool</a></li></ul></li><li><a href=#7-related-material>7. Related material</a></li></ul><h1 id=abstract>Abstract</h1><p>Decentralized data storage networks, such as Filecoin, Arweave and Storj, have achieved a new round of decentralized data development infrastructure by creating tamper-proof and secure storage functions. IceGiant extends the functions provided by these data storage networks through NoSQL database synchronization protocol. IceGiant protocol supports rapid decentralized development, and enriches the data expression layer of application systems by using richer NoSQL data structures (such as hash, list, set) and data instructions, so as to improve the usability of web3/web2 system for decentralized networks and data.</p><h1 id=1-introduce>1. Introduce</h1><h2 id=11-motivation>1.1 Motivation</h2><p>For the web3 field, there is currently no way to write a complete client application as easily as in web2, and make it completely decentralized. In web2, you start a database on AWS and let your client application call the database for reading and writing. But there is nothing like it in web3. You can&rsquo;t just write data to Ethereum, which is too expensive for most users. Storage protocols such as Filecoin and Arweave are mainly used to archive data, but they do not provide enterprise-level performance guarantee for writing and reading data.</p><p>In this article, we introduce IceGiant, which is a novel solution that can realize highly scalable and decentralized NoSQL database. Using RESP as the main interactive protocol, IceGiant supports rapid, complex and decentralized development, while eliminating the need for developers to learn any new skills and languages.</p><p>Using the advantages of IceGiant can be divided into four different categories:</p><ol><li>Greatly shorten the development time.</li><li>Enhance the functions and customization of web3/web2 applications</li><li>Fast data query speed and loading time</li><li>Enhance the simplicity of data combination and complex data usage scenarios.</li></ol><p>Firstly, the implementation of distributed NoSQL database enables almost every developer to build on the decentralized architecture. RESP, as a popular communication protocol of Redis database in the world, has now become the main communication protocol of NoSQL database. Redis, as the NoSQL database with the first market share in web2 environment, is widely used by developers all over the world. By being compatible with RESP communication protocol, IceGiant greatly reduces the development time and technical threshold, thus promoting the development of decentralized applications.</p><p>IceGiant also supports the development of some functions that were previously impossible in web3. By providing developers with a full-featured NoSQL engine, IceGiant allows developers to perform complex queries on massive data sets within milliseconds. This level of optimization can further push web3 applications into a data-driven state without sacrificing the decentralized nature of its products.</p><p>The key to the large-scale adoption of web3 technology is that it can provide the end users with the user experience they have become accustomed to in web2. The loading time of web pages directly affects the conversion rate of business. Wal-Mart found that the conversion rate will increase by 2% every time the page loading time is reduced by one second. The gateway loading time of web3 distributed storage still needs to be optimized. The core goal of IceGiant is to provide users with a fast and rich data structure NoSQL data set system.</p><p>Finally, IceGiant provides richer data expression and data combination functions. For the current dilemma that web3 can only read and write in KV, we provide strings\hashes\lists\sorted sets\sets data structure to achieve unprecedented interoperability at application data level. IceGiant supports the conventional RESP communication protocol. Whether developers want to use application data sets or are interested in specific data segments, IceGiant provides a simple and efficient way to use data.</p><h2 id=12-glossary-of-terms>1.2 Glossary of Terms</h2><table><thead><tr><th>Item</th><th>describe</th></tr></thead><tbody><tr><td>NoSQL</td><td>Non-relational databases, which store data in a format different from relational tables.</td></tr><tr><td>data set</td><td>The only identifiable data set in the database, including the location and status of all past data.</td></tr><tr><td>Smart contracts</td><td>A computer protocol designed to disseminate, verify or execute contracts in an information way.</td></tr><tr><td>FVM</td><td>Smart Contract Virtual Machine of Filecoin</td></tr><tr><td>IPFS-LOG</td><td>IPFS-log is an immutable, operation-based collision-free replication data structure (CRDT) for distributed systems. It is an append-only log that can be used to model the variable sharing state between peers in p2p applications.</td></tr><tr><td>validator</td><td>Provide data verification for the data on the chain, and maintain a complete database state.</td></tr></tbody></table><h1 id=2system-composition>2.System composition</h1><h2 id=21-network-structure>2.1 Network structure</h2><p>Although all IceGiant nodes are in the same P2P network, the structure of the network can be decomposed according to the data set, which is the data tenant isolation area, which refers to the database area used by a specific application on top of the IceGiant protocol. Different from the traditional blockchain network, IceGiant nodes are only responsible for interacting with peers operating the same data set, and are not responsible for any data of other data sets. Peer IceGiant node sets form a high-availability data storage area.</p><p><img src=https://user-images.githubusercontent.com/34047788/195057766-c35b7455-95e1-4bb4-a4a2-ad0f6c2989b6.png alt=image></p><h2 id=22-storage-mechanism>2.2 Storage mechanism</h2><p>The NoSQL storage layer of each individual IceGiant mainly includes the codec layer and the underlying KV storage layer. the underlying KV engine currently supports levelDB, badgerDB, IPFS and OSS, and the main data storage includes two ways:</p><ol><li>instruction broadcast model based on IPFS-log</li><li>Native data storage model based on IPFS</li></ol><p>The specific storage model design will be further described in Section 3.3 NoSQL Storage Engine. Multiple IceGiant nodes will be divided into groups according to data sets, and each group will form a highly available storage area structure.</p><h2 id=22-smart-contracts>2.2 Smart contracts</h2><p>IceGiant mainly uses smart contracts to build a decentralized storage engine strategy center. Our goal is to build a database platform that can run by itself and be governed by the public. At present, the running carrier of smart contracts mainly considers EVM-compatible virtual machine environment. First, we choose FVM as our decentralized management platform. FVM, as the computing layer of FileCoin storage ecology, allows us to make trusted calculations and provide services closer to data storage, and provides users with more reliable data operation credibility.</p><p>Intelligent contract functions mainly include:</p><ol><li>Data set and multi-tenant decentralized trusted management</li><li>User account and access credentials management</li><li>The NoSQL database is written into the contract storage of instruction set for data trusted synchronization and data consistency verification.</li></ol><h2 id=23-query-structure>2.3 Query structure</h2><p>In each query submitted to a node, there are the following pieces of different data:</p><ol><li>query: Standard RESP protocol query</li><li>timestamp</li><li>query hash</li><li>query id</li><li>RSA signature</li></ol><p>Every time data is written, the node ensures that the RSA signature is valid for the associated key of the fund pool, and the public key is stored in the smart contract. After verifying the signature, the node checks the timestamp to ensure that it falls within the valid time range of the current block.</p><p>Once the timestamp is accepted, the node checks the uniqueness of the query ID. The query ID is guaranteed by the node that it can&rsquo;t be duplicated within the batch within the current time range, and it can take random 64 characters associated with the query. If the node is a leader, it is also necessary to maintain the current state of the data set in the database.</p><h1 id=3node-architectur>3.Node architectur</h1><h2 id=31-reverse-proxy>3.1 Reverse proxy</h2><p>The reverse proxy server is the entry point for all requests sent to the node. On the IceGiant node, the reverse proxy server has four main purposes:</p><ol><li>Manage TLS/SSL certificates to ensure encrypted communication with any client/peer node.</li><li>Implement CORS (cross-source resource sharing) configuration, and specify which sources (client and peer) to accept data read/write from.</li><li>Route incoming requests to the correct gateway or synchronizer, and prevent bypassing any advanced request gateway.</li><li>Provide static resources from the local file system.</li></ol><h2 id=32-icegiant-synchronize>3.2 IceGiant synchronize</h2><p>IceGiant Synchronizer is an application directly above the database engine. All incoming database requests pass through IceGiant Synchronizer, which determines whether the requests should be processed, whether data writes should be propagated to other parts of the network, and whether local data should be written and customer requests should be responded to.</p><p>IceGiant Synchronizer can also provide data write aggregation function, allowing multiple data requests to be merged and written into a single network storage request. It also allows users to cross-mix data sets between different nodes, encouraging further data decentralization, while keeping the operation overhead low.</p><h2 id=33-nosql-storage-engine>3.3 NoSQL storage engine</h2><p>The core of each node is the database engine. By default, IceGiant node integrates KV storage engines such as levelDB, badgerDB, IPFS, OSS, etc., and implements the protocol coding layer of NoSQL on the KV storage relationship. Currently, the data storage of NoSQL mainly includes the following two ways:</p><p><strong>The first implementation: instruction broadcast model based on ipfs-log</strong>: Based on ipfs-log,crdt and libp2p(pubsub), an immutable and operation-based conflict-free replication data model for distributed systems is implemented. Based on ipfs-log, various data structures such as event and kv are encapsulated, and multi-node database instruction broadcast is implemented based on this engine;At that bottom of IceFireDB, we abstract the variable kv engine base on badgerdb and leveldb. any node will broadcast the whole network when it is writing instruction, and the bottom driver of IceFireDB of each node will execute the broadcast instruction to ensure the final consistency of data.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>           <span style=color:#a6e22e>Log</span> <span style=color:#a6e22e>A</span>                <span style=color:#a6e22e>Log</span> <span style=color:#a6e22e>B</span>
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>logA</span>.append(<span style=color:#e6db74>&#34;one&#34;</span>)   <span style=color:#a6e22e>logB</span>.append(<span style=color:#e6db74>&#34;hello&#34;</span>)
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>             <span style=color:#a6e22e>v</span>                    <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>+-----+</span>             <span style=color:#f92672>+-------+</span>
</span></span><span style=display:flex><span>          |<span style=color:#e6db74>&#34;one&#34;</span>|             |<span style=color:#e6db74>&#34;hello&#34;</span>|
</span></span><span style=display:flex><span>          <span style=color:#f92672>+-----+</span>             <span style=color:#f92672>+-------+</span>
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>logA</span>.append(<span style=color:#e6db74>&#34;two&#34;</span>)   <span style=color:#a6e22e>logB</span>.append(<span style=color:#e6db74>&#34;world&#34;</span>)
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>             <span style=color:#a6e22e>v</span>                    <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>+-----------+</span>       <span style=color:#f92672>+---------------+</span>
</span></span><span style=display:flex><span>       |<span style=color:#e6db74>&#34;one&#34;</span>,<span style=color:#e6db74>&#34;two&#34;</span>|       |<span style=color:#e6db74>&#34;hello&#34;</span>,<span style=color:#e6db74>&#34;world&#34;</span>|
</span></span><span style=display:flex><span>       <span style=color:#f92672>+-----------+</span>       <span style=color:#f92672>+---------------+</span>
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>             |                    |
</span></span><span style=display:flex><span>       <span style=color:#a6e22e>logA</span>.<span style=color:#a6e22e>join</span>(<span style=color:#a6e22e>logB</span>) <span style=color:#f92672>&lt;----------+</span>
</span></span><span style=display:flex><span>             |
</span></span><span style=display:flex><span>             <span style=color:#a6e22e>v</span>
</span></span><span style=display:flex><span><span style=color:#f92672>+---------------------------+</span>
</span></span><span style=display:flex><span>|<span style=color:#e6db74>&#34;one&#34;</span>,<span style=color:#e6db74>&#34;hello&#34;</span>,<span style=color:#e6db74>&#34;two&#34;</span>,<span style=color:#e6db74>&#34;world&#34;</span>|
</span></span><span style=display:flex><span><span style=color:#f92672>+---------------------------+</span>
</span></span></code></pre></div><p><strong>The second implementation: full storage model based on ipfs</strong>: In addition to the first implementation mode, we are also building the structure of the second type of data, so that the complete data will grow on ipfs. At first, there is an ipfs driver in the IceFireDB driver layer, which will encode and process the upper-level commands into a unified kv data structure, store and change the value, and the generated new cid will be connected with key. However, at present, there is no key broadcast network with multiple nodes and data synchronization. When we connect with the broadcast network, we can build a data model originally grown on ipfs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>+-+---------------+----+---------------+----+---------------+-+</span>
</span></span><span style=display:flex><span>|                           <span style=color:#a6e22e>Transport</span>                         |
</span></span><span style=display:flex><span>| <span style=color:#f92672>+---------------+</span>    <span style=color:#f92672>+---------------+</span>    <span style=color:#f92672>+---------------+</span> |
</span></span><span style=display:flex><span>| |    <span style=color:#a6e22e>Cluster</span>    |    |    <span style=color:#a6e22e>Cluster</span>    |    |    <span style=color:#a6e22e>Cluster</span>    | |
</span></span><span style=display:flex><span>| | <span style=color:#a6e22e>communication</span> |    | <span style=color:#a6e22e>communication</span> |    | <span style=color:#a6e22e>communication</span> | |
</span></span><span style=display:flex><span>| <span style=color:#f92672>+---------------+</span>    <span style=color:#f92672>+---------------+</span>    <span style=color:#f92672>+---------------+</span> |
</span></span><span style=display:flex><span><span style=color:#f92672>+-+---------------+----+-------</span>^<span style=color:#f92672>-------+----+---------------+-+</span>
</span></span><span style=display:flex><span>                               |
</span></span><span style=display:flex><span><span style=color:#f92672>+------------------------------</span><span style=color:#a6e22e>v</span><span style=color:#f92672>------------------------------+</span>
</span></span><span style=display:flex><span>|                        <span style=color:#a6e22e>Query</span> <span style=color:#a6e22e>Processor</span>                      |
</span></span><span style=display:flex><span>|   <span style=color:#f92672>+-----------------------------------------------------+</span>   |
</span></span><span style=display:flex><span>|   |                     <span style=color:#a6e22e>Query</span> <span style=color:#a6e22e>Parser</span>                    |   |
</span></span><span style=display:flex><span>|   <span style=color:#f92672>+-----------------------------------------------------+</span>   |
</span></span><span style=display:flex><span>|   <span style=color:#f92672>+-----------------------------------------------------+</span>   |
</span></span><span style=display:flex><span>|   |                   <span style=color:#a6e22e>Query</span> <span style=color:#a6e22e>Optimizer</span>                   |   |
</span></span><span style=display:flex><span>|   <span style=color:#f92672>+-----------------------------------------------------+</span>   |
</span></span><span style=display:flex><span><span style=color:#f92672>+---+--------------------------+--------------------------+---+</span>
</span></span><span style=display:flex><span>                               |
</span></span><span style=display:flex><span><span style=color:#f92672>+------------------------------</span><span style=color:#a6e22e>v</span><span style=color:#f92672>------------------------------+</span>
</span></span><span style=display:flex><span>|                            <span style=color:#a6e22e>Codec</span>                            |
</span></span><span style=display:flex><span>|    <span style=color:#f92672>+-----------+</span>                           <span style=color:#f92672>+-----------+</span>    |
</span></span><span style=display:flex><span>|    |   <span style=color:#a6e22e>Encode</span>  |                           |   <span style=color:#a6e22e>Decode</span>  |    |
</span></span><span style=display:flex><span>|    <span style=color:#f92672>+-----------+</span>                           <span style=color:#f92672>+-----------+</span>    |
</span></span><span style=display:flex><span>|                 <span style=color:#a6e22e>support</span>: <span style=color:#a6e22e>kv</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#a6e22e>list</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#a6e22e>hash</span><span style=color:#960050;background-color:#1e0010>、</span><span style=color:#a6e22e>set</span>                 |
</span></span><span style=display:flex><span><span style=color:#f92672>+----------+---------------------------------------</span>^<span style=color:#f92672>----------+</span>
</span></span><span style=display:flex><span>           |                                       |
</span></span><span style=display:flex><span><span style=color:#f92672>+----------+---------------------------------------+----------+</span>
</span></span><span style=display:flex><span>|          |<span style=color:#a6e22e>put</span>              <span style=color:#a6e22e>KV</span> <span style=color:#a6e22e>Engine</span>             |<span style=color:#a6e22e>Get</span>       |
</span></span><span style=display:flex><span>|    <span style=color:#f92672>+-----</span><span style=color:#a6e22e>v</span><span style=color:#f92672>----+</span>                            <span style=color:#f92672>+-----+----+</span>     |
</span></span><span style=display:flex><span>|    | <span style=color:#a6e22e>put</span>(<span style=color:#a6e22e>a</span>,<span style=color:#a6e22e>b</span>) |                            |  <span style=color:#a6e22e>Get</span>(<span style=color:#a6e22e>a</span>)  |     |
</span></span><span style=display:flex><span>|    <span style=color:#f92672>+-----+----+</span>                            <span style=color:#f92672>+-----+----+</span>     |
</span></span><span style=display:flex><span>|          | <span style=color:#a6e22e>a</span>:<span style=color:#a6e22e>b</span>            <span style=color:#f92672>+-------+</span>              | <span style=color:#a6e22e>a</span>        |
</span></span><span style=display:flex><span>|    <span style=color:#f92672>+-----</span><span style=color:#a6e22e>v</span><span style=color:#f92672>----+</span>    <span style=color:#f92672>+------</span>&gt; <span style=color:#a6e22e>store</span> <span style=color:#f92672>&lt;----+</span>   <span style=color:#f92672>+-----</span><span style=color:#a6e22e>v</span><span style=color:#f92672>----+</span>     |
</span></span><span style=display:flex><span>|    |  <span style=color:#a6e22e>CID</span>(<span style=color:#a6e22e>b</span>)  <span style=color:#f92672>+----+</span>      <span style=color:#f92672>+-------+</span>    <span style=color:#f92672>+---+</span> <span style=color:#a6e22e>cat</span>(<span style=color:#a6e22e>hash</span>)|     |
</span></span><span style=display:flex><span>|    <span style=color:#f92672>+-----+----+</span>                            <span style=color:#f92672>+-----+----+</span>     |
</span></span><span style=display:flex><span>|          | <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>b</span>)                                | <span style=color:#a6e22e>cat</span>      |
</span></span><span style=display:flex><span>|  <span style=color:#f92672>--------</span><span style=color:#a6e22e>v</span><span style=color:#f92672>---------------------------------------</span><span style=color:#a6e22e>v</span><span style=color:#f92672>-----</span>     |
</span></span><span style=display:flex><span>|                          <span style=color:#a6e22e>IPFS</span> <span style=color:#a6e22e>nodes</span>                         |
</span></span><span style=display:flex><span><span style=color:#f92672>+-------------------------------------------------------------+</span>
</span></span></code></pre></div><p>Each IceGiant node is a perfect NoSQL database engine, and each database engine is configured to allow access only through the IceGiant synchronizer running on the same machine. There are the following considerations in doing so:</p><ol><li>Restrict synchronizer&rsquo;s access to database, and reduce the chance of user&rsquo;s error. Non-propagating data writes must be clearly identified by IceGiant synchronizer, rather than accidentally submitted to NoSQL database storage engine, which makes similar nodes in the network contain the same data as much as possible.</li><li>Restrict access to IceGiant synchronizer through reverse proxy or other advanced gateways, so that database users can reduce attack vectors, thus reducing the vicious situation of network abuse by bots, data/privacy leakage and cross-node status differences.</li></ol><h2 id=34-advanced-request-handler>3.4 Advanced request handler</h2><p>IceGiant node can choose to be equipped with an advanced request processing gateway, the core of which is an application middleware, which can contain complex business logic to define database interaction. This can develop the function of IceGiant node from database/data storage system to a fully functional decentralized API system. Examples of high-level request gateways that can be built include: fine-grained database access, complex aggregate queries and concurrent queries, and rules of which data to pass to IceGiant synchronizer for propagation.</p><p>For example, we can build a multi-tenant management page to run on an advanced request gateway, which manages application-specific logic. The advantage of such a system is that it only needs one gateway to verify access rights.</p><h1 id=4-smart-contracts>4. Smart contracts</h1><h2 id=41-transaction-structure>4.1 Transaction Structure</h2><p>IceGiant blocks are stored in JSON format when submitted to smart contracts. Because each IceGiant node can serve multiple data sets, a single smart contract transaction can contain multiple blocks.</p><p>In each JSON, the top key is the name of the data set referenced by the data. Below the key in the first layer is the request endpoint that receives data writes. After the data is divided by the request endpoint, all data writes are sorted in chronological order.</p><h2 id=42-contract-interaction>4.2 Contract interaction</h2><p>The main functions of data set existence, ownership and verification come from intelligent contracts, which are mainly used to construct data set isolation, data reading and writing logs, fund pool, data legality and consistency verification.</p><h1 id=5index-tracking-block-metadata>5.Index: tracking block metadata</h1><h2 id=51-ifdb-token>5.1 $IFDB token</h2><p>The native token of IceGiant and IceFireDB ecosystem is $IFDB token, which has the following purposes:</p><ol><li>The main purpose of the token is to let interested parties verify the incoming blocks of the database. This can occur in the form of stakeholders running peer verifier nodes, or by entrusting benefits to verifiers.</li><li>Token mechanism prevents network spam requests. As the name of the data set is unique, registering the data set consumes a small amount of tokens, creating a small entry barrier, which can be ignored by well-meaning users.</li></ol><h2 id=52-sales-verification-node-program>5.2 Sales Verification Node Program</h2><p>The master validator in the IceGiant validator pool is the node with the highest stake/delegated stake. This node can be managed by individuals/groups closely related to the project it serves, but in theory it can be run by any third party.</p><p>The lead validator is the default node to which any queries are sent and is responsible for serving all application data (this is the default, but not mandatory). In addition to tracking appropriate state changes, the master validator also runs a database that runs the active state of the dataset. The benefit of making this the default is that it significantly reduces the overall cost of maintaining the dataset for nodes. Projects can choose to create more &ldquo;expensive&rdquo; datasets and thus benefit from further decentralization, but in most use cases any further decentralization will result in diminishing marginal utility.</p><p>Any stake owned or delegated to the master validator cannot be taken away until the validator&rsquo;s most recent block is complete. Once a block is mined by the new lead validator, the lead validator can remove their stake from the pool. The lead validator can request to unmark when mining its final block, preventing the token from being locked into its role.</p><h2 id=53-peer-verifier>5.3 Peer verifier</h2><p>Any validator that is not a leader is a peer validator, and by default it is the role of a peer validator to track incoming data writes and ensure that these writes are properly stored on IPFS by the master validator.</p><p>Peer validators may also choose to maintain an active state of the database, allowing them to be queried just like the master validator. Some network users may want to do this as it acts as a mechanism to eliminate the risk of network downtime. Additionally, the highest-level validators may have a vested interest in maintaining the active state of the database as they become the next primary validator at any time.</p><h1 id=6funding-pool-multi-chain-support>6.Funding pool: multi-chain support</h1><h2 id=61-evm-multi-chain-fund-pool>6.1 EVM multi-chain fund pool</h2><p>Funding pools enable individuals and communities to pay for data usage on any number of blockchains. The fund pool is just a smart contract that holds funds for the validator and can be used to incentivize the validator to act correctly, and the tokens in the fund pool are used to pay the operator&rsquo;s storage, computing and hardware costs.</p><p>A dataset can have any number of pools. When creating a pool, the creator can specify the chain, token, and validator that the pool is bound to. This allows users to pay into the IceGiant network with any ERC20 equivalent token. By allowing payments in any token, IceGiant creates a chain-agnostic NoSQL database that utilizes smart contracts as a state tracking layer.</p><h1 id=7-related-material>7. Related material</h1><ol><li><p>Deterministic Databases and the Future of Data Sharing： <a href=https://thenewstack.io/deterministic-databases-and-the-future-of-data-sharing/>https://thenewstack.io/deterministic-databases-and-the-future-of-data-sharing/</a></p></li><li><p>Relational to NoSQL at Enterprise Scale: Lessons from Amazon： <a href=https://thenewstack.io/relational-to-nosql-at-enterprise-scale-lessons-from-amazon/>https://thenewstack.io/relational-to-nosql-at-enterprise-scale-lessons-from-amazon/</a></p></li><li><p>How website performance affects conversion rates：https://www.cloudflare.com/learning/performance/more/website-performance-conversion-rates/</p></li></ol></article><div class=article-info>2022-10-02</div></div><div class=footer><p>Copyright &copy; IceGiant WhitePaper</p></div></div></body></html>