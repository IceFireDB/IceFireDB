<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
  icefiredb-crdt-kv
  #


  Project introduction
  #

The IceFireDB-CRDT-KV engine can support decentralized P2P networking, data synchronization and consistency between nodes. It is a component of the IceFireDB software ecosystem, thanks to the open source of IPFS.

  Features
  #


Easy access to P2P data consistency function
Stable decentralized networking function
Friendly program access interface


  Installing
  #

go get -u github.com/IceFireDB/icefiredb-crdt-kv

  Example
  #

package main

import (
	"bufio"
	"context"
	"fmt"
	icefiredb_crdt_kv "github.com/IceFireDB/icefiredb-crdt-kv/kv"
	badger2 "github.com/dgraph-io/badger"
	"github.com/ipfs/go-datastore/query"
	"github.com/sirupsen/logrus"
	"os"
	"strings"
)

func main() {
	ctx := context.TODO()
	log := logrus.New()
	db, err := icefiredb_crdt_kv.NewCRDTKeyValueDB(ctx, icefiredb_crdt_kv.Config{
		NodeServiceName:     "icefiredb-crdt-kv",
		DataSyncChannel:     "icefiredb-crdt-kv-data",
		NetDiscoveryChannel: "icefiredb-crdt-kv-net",
		Namespace:           "test",
		Logger:              log,
	})
	if err != nil {
		panic(err)
	}

	defer db.Close()

	fmt.Printf("> ")
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		text := scanner.Text()
		fields := strings.Fields(text)
		if len(fields) == 0 {
			fmt.Printf("> ")
			continue
		}

		cmd := fields[0]
		switch cmd {
		case "exit", "quit":
			return
		case "get":
			if len(fields) < 2 {
				printVal("missing key")
				continue
			}
			val, err := db.Get(ctx, []byte(fields[1]))
			if err != nil {
				printVal(err)
				continue
			}
			printVal(string(val))
		case "put":
			if len(fields) < 3 {
				printVal("Missing parameters")
				continue
			}

			printVal(db.Put(ctx, []byte(fields[1]), []byte(fields[2])))
		case "delete":
			if len(fields) < 2 {
				printVal("missing key")
				continue
			}
			printVal(db.Delete(ctx, []byte(fields[1])))
		case "has":
			if len(fields) < 2 {
				printVal("missing key")
				continue
			}
			is, err := db.Has(ctx, []byte(fields[1]))
			if err != nil {
				printVal(err)
				continue
			}
			printVal(is)
		case "list":
			result, err := db.Query(ctx, query.Query{})
			if err != nil {
				printVal(err)
				continue
			}
			for val := range result.Next() {
				fmt.Printf(fmt.Sprintf("%s => %v\n", val.Key, string(val.Value)))
			}
			fmt.Print("> ")
		case "query":
			if len(fields) < 2 {
				printVal("missing query condition")
				continue
			}
			//fmt.Println(fields[1], len(fields[1]))
			q := query.Query{
				//Prefix: fields[1],
				Filters: []query.Filter{
					query.FilterKeyPrefix{
						Prefix: fields[1],
					},
				},
			}
			result, err := db.Query(ctx, q)
			if err != nil {
				printVal(err)
				continue
			}
			//time.Sleep(time.Second)
			for val := range result.Next() {
				fmt.Printf(fmt.Sprintf("%s => %v\n", val.Key, string(val.Value)))
			}
			fmt.Print("> ")

		case "connect": // 主动连接
			if len(fields) < 2 {
				printVal("Missing connection address")
				continue
			}
			err = db.Connect(fields[1])
			if err == nil {
				printVal("connection succeeded!")
			} else {
				printVal(err)
			}
		case "slist":
			result, err := db.Store().Query(ctx, query.Query{})
			if err != nil {
				printVal(err)
				continue
			}
			for val := range result.Next() {
				fmt.Printf(fmt.Sprintf("%s => %v\n", val.Key, string(val.Value)))
			}
			fmt.Print("> ")
		case "bquery":
			if len(fields) < 2 {
				printVal("missing query condition")
				continue
			}
			db.DB().View(func(txn *badger2.Txn) error {
				opts := badger2.DefaultIteratorOptions
				opts.PrefetchSize = 10
				it := txn.NewIterator(opts)
				defer it.Close()
				prefix := []byte(fields[1])
				for it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() {
					item := it.Item()
					k := item.Key()
					err := item.Value(func(v []byte) error {
						fmt.Printf("key=%s, value=%s\n", k, v)
						return nil
					})
					if err != nil {
						return err
					}
				}
				return nil
			})

		case "blist":
			db.DB().View(func(txn *badger2.Txn) error {
				opts := badger2.DefaultIteratorOptions
				opts.PrefetchSize = 10
				it := txn.NewIterator(opts)
				defer it.Close()
				for it.Rewind(); it.Valid(); it.Next() {
					item := it.Item()
					k := item.Key()
					err := item.Value(func(v []byte) error {
						fmt.Printf("key=%s, value=%s\n", k, v)
						return nil
					})
					if err != nil {
						return err
					}
				}
				return nil
			})
		default:
			printVal("")
		}
	}
}

func printVal(v interface{}) {
	fmt.Printf("%v\n> ", v)
}

  RoadMap
  #


Optimize project structure.
Encapsulates the kv engine layer for easy reference by upper-layer applications.
'><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:type" content="website"><meta property="og:image" content="https://res.cloudinary.com/malloc/image/upload/v1666510486/icefiredb/logo_z8koem.png"><meta property="og:url" content="https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/develop/icefiredb-crdt-kv/"><meta property="og:site_name" content="IceFireDB Documentation"><meta property="og:title" content="icefiredb-crdt-kv"><meta property="og:description" content=' icefiredb-crdt-kv # Project introduction # The IceFireDB-CRDT-KV engine can support decentralized P2P networking, data synchronization and consistency between nodes. It is a component of the IceFireDB software ecosystem, thanks to the open source of IPFS.
Features # Easy access to P2P data consistency function Stable decentralized networking function Friendly program access interface Installing # go get -u github.com/IceFireDB/icefiredb-crdt-kv Example # package main import ( "bufio" "context" "fmt" icefiredb_crdt_kv "github.com/IceFireDB/icefiredb-crdt-kv/kv" badger2 "github.com/dgraph-io/badger" "github.com/ipfs/go-datastore/query" "github.com/sirupsen/logrus" "os" "strings" ) func main() { ctx := context.TODO() log := logrus.New() db, err := icefiredb_crdt_kv.NewCRDTKeyValueDB(ctx, icefiredb_crdt_kv.Config{ NodeServiceName: "icefiredb-crdt-kv", DataSyncChannel: "icefiredb-crdt-kv-data", NetDiscoveryChannel: "icefiredb-crdt-kv-net", Namespace: "test", Logger: log, }) if err != nil { panic(err) } defer db.Close() fmt.Printf("> ") scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { text := scanner.Text() fields := strings.Fields(text) if len(fields) == 0 { fmt.Printf("> ") continue } cmd := fields[0] switch cmd { case "exit", "quit": return case "get": if len(fields) < 2 { printVal("missing key") continue } val, err := db.Get(ctx, []byte(fields[1])) if err != nil { printVal(err) continue } printVal(string(val)) case "put": if len(fields) < 3 { printVal("Missing parameters") continue } printVal(db.Put(ctx, []byte(fields[1]), []byte(fields[2]))) case "delete": if len(fields) < 2 { printVal("missing key") continue } printVal(db.Delete(ctx, []byte(fields[1]))) case "has": if len(fields) < 2 { printVal("missing key") continue } is, err := db.Has(ctx, []byte(fields[1])) if err != nil { printVal(err) continue } printVal(is) case "list": result, err := db.Query(ctx, query.Query{}) if err != nil { printVal(err) continue } for val := range result.Next() { fmt.Printf(fmt.Sprintf("%s => %v\n", val.Key, string(val.Value))) } fmt.Print("> ") case "query": if len(fields) < 2 { printVal("missing query condition") continue } //fmt.Println(fields[1], len(fields[1])) q := query.Query{ //Prefix: fields[1], Filters: []query.Filter{ query.FilterKeyPrefix{ Prefix: fields[1], }, }, } result, err := db.Query(ctx, q) if err != nil { printVal(err) continue } //time.Sleep(time.Second) for val := range result.Next() { fmt.Printf(fmt.Sprintf("%s => %v\n", val.Key, string(val.Value))) } fmt.Print("> ") case "connect": // 主动连接 if len(fields) < 2 { printVal("Missing connection address") continue } err = db.Connect(fields[1]) if err == nil { printVal("connection succeeded!") } else { printVal(err) } case "slist": result, err := db.Store().Query(ctx, query.Query{}) if err != nil { printVal(err) continue } for val := range result.Next() { fmt.Printf(fmt.Sprintf("%s => %v\n", val.Key, string(val.Value))) } fmt.Print("> ") case "bquery": if len(fields) < 2 { printVal("missing query condition") continue } db.DB().View(func(txn *badger2.Txn) error { opts := badger2.DefaultIteratorOptions opts.PrefetchSize = 10 it := txn.NewIterator(opts) defer it.Close() prefix := []byte(fields[1]) for it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() { item := it.Item() k := item.Key() err := item.Value(func(v []byte) error { fmt.Printf("key=%s, value=%s\n", k, v) return nil }) if err != nil { return err } } return nil }) case "blist": db.DB().View(func(txn *badger2.Txn) error { opts := badger2.DefaultIteratorOptions opts.PrefetchSize = 10 it := txn.NewIterator(opts) defer it.Close() for it.Rewind(); it.Valid(); it.Next() { item := it.Item() k := item.Key() err := item.Value(func(v []byte) error { fmt.Printf("key=%s, value=%s\n", k, v) return nil }) if err != nil { return err } } return nil }) default: printVal("") } } } func printVal(v interface{}) { fmt.Printf("%v\n> ", v) } RoadMap # Optimize project structure. Encapsulates the kv engine layer for easy reference by upper-layer applications. '><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="icefiredb"><title>icefiredb-crdt-kv | IceFireDB Documentation</title>
<link rel=manifest href=/icefiredb_docs/manifest.json><link rel=icon href=/icefiredb_docs/favicon.ico type=image/x-icon><link rel=stylesheet href=/icefiredb_docs/book.min.b217cc02c67832c758393b43eb4be5c8cf053fb3c4a02dee3fdd3805ce53f993.css integrity="sha256-shfMAsZ4MsdYOTtD60vlyM8FP7PEoC3uP904Bc5T+ZM=" crossorigin=anonymous><script defer src=/icefiredb_docs/flexsearch.min.js></script><script defer src=/icefiredb_docs/en.search.min.e2d4ffbe7302880d97331bdf5598cd4a2e1adc1179e111d1cae5f4bedfad98a3.js integrity="sha256-4tT/vnMCiA2XMxvfVZjNSi4a3BF54RHRyuX0vt+tmKM=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/icefiredb_docs/><span>IceFireDB Documentation</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://www.icefiredb.xyz/ target=_blank rel=noopener>Official Site</a></li><li><a href=https://github.com/icefiredb target=_blank rel=noopener>Open Source</a></li></ul><ul><li class=book-section-flat><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/>Overview</a><ul><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/engine_overview/>Engine Overview</a><ul></ul></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/vocabulary/>Vocabulary</a><ul></ul></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/>IceFireDB NoSQL Engine</a><ul><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/quick_start/>Quick Start</a><ul></ul></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/designs/>Designs</a><ul><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/designs/overview/>Overview</a></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/designs/network/>Network layer</a></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/designs/storage/>Storage layer</a></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/designs/protocol/>Protocol layer</a></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/designs/codec/>Codec layer</a></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/designs/storage-drivers/>Storage Drivers</a></li></ul></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/tutorials/>Tutorials</a><ul><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/tutorials/getting-started/>Getting Started Tutorial</a></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/tutorials/performance-benchmarking/>Performance Benchmarking</a></li></ul></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/deploy/>Deploy</a><ul><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/deploy/configuration/>Configuration Guide</a></li></ul></li><li><span>Develop</span><ul><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/develop/icefiredb-crdt-kv/ class=active>icefiredb-crdt-kv</a></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/develop/icefiredb-ipfs-log/>icefiredb-ipfs-log</a></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/develop/icefiredb_proxy/>icefiredb-proxy</a></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/develop/redhub/>redhub-frame</a></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/develop/api-reference/>API Reference</a></li></ul></li><li><span>Project Comparison</span><ul><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/project-comparison/orbitdb/>OrbitDB</a></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-nosql/project-comparison/threaddb/>ThreadDB</a></li></ul></li></ul></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-sqlite/>IceFireDB-SQLite</a><ul><li><input type=checkbox id=section-d28adc5f935baf9f2270b11342515dec class=toggle>
<label for=section-d28adc5f935baf9f2270b11342515dec class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-sqlite/architecture/overview/>Overview</a></li></ul></li></ul></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-redis-proxy/>IceFireDB-Redis-Proxy</a><ul><li><input type=checkbox id=section-197cd7a03ef88813eee099fa35466d3e class=toggle>
<label for=section-197cd7a03ef88813eee099fa35466d3e class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-redis-proxy/architecture/overview/>Overview</a></li></ul></li></ul></li><li><span>IceFireDB-SQLProxy</span><ul><li><input type=checkbox id=section-87903bd5b525679072ad1825563a57f2 class=toggle>
<label for=section-87903bd5b525679072ad1825563a57f2 class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-sqlproxy/architecture/overview/>Overview</a></li></ul></li></ul></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-pubsub/>IceFireDB-PubSub</a><ul><li><input type=checkbox id=section-d2e27c9da60e491bca2bc610c135b235 class=toggle>
<label for=section-d2e27c9da60e491bca2bc610c135b235 class="flex justify-between"><a role=button>Architecture</a></label><ul><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/icefiredb-pubsub/architecture/overview/>Overview</a></li></ul></li></ul></li><li><a href=https://docs.icefiredb.xyz/icefiredb_docs/icefiredb/faqs/>Frequently Asked Questions</a><ul></ul></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/icefiredb_docs/svg/menu.svg class=book-icon alt=Menu>
</label><strong>icefiredb-crdt-kv</strong>
<label for=toc-control><img src=/icefiredb_docs/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#project-introduction>Project introduction</a></li><li><a href=#features>Features</a></li><li><a href=#installing>Installing</a></li><li><a href=#example>Example</a></li><li><a href=#roadmap>RoadMap</a></li></ul></nav></aside></header><article class=markdown><h1 id=icefiredb-crdt-kv>icefiredb-crdt-kv
<a class=anchor href=#icefiredb-crdt-kv>#</a></h1><h2 id=project-introduction>Project introduction
<a class=anchor href=#project-introduction>#</a></h2><p>The IceFireDB-CRDT-KV engine can support decentralized P2P networking, data synchronization and consistency between nodes. It is a component of the IceFireDB software ecosystem, thanks to the open source of IPFS.</p><h2 id=features>Features
<a class=anchor href=#features>#</a></h2><ol><li>Easy access to P2P data consistency function</li><li>Stable decentralized networking function</li><li>Friendly program access interface</li></ol><h2 id=installing>Installing
<a class=anchor href=#installing>#</a></h2><pre tabindex=0><code>go get -u github.com/IceFireDB/icefiredb-crdt-kv
</code></pre><h2 id=example>Example
<a class=anchor href=#example>#</a></h2><pre tabindex=0><code>package main

import (
	&#34;bufio&#34;
	&#34;context&#34;
	&#34;fmt&#34;
	icefiredb_crdt_kv &#34;github.com/IceFireDB/icefiredb-crdt-kv/kv&#34;
	badger2 &#34;github.com/dgraph-io/badger&#34;
	&#34;github.com/ipfs/go-datastore/query&#34;
	&#34;github.com/sirupsen/logrus&#34;
	&#34;os&#34;
	&#34;strings&#34;
)

func main() {
	ctx := context.TODO()
	log := logrus.New()
	db, err := icefiredb_crdt_kv.NewCRDTKeyValueDB(ctx, icefiredb_crdt_kv.Config{
		NodeServiceName:     &#34;icefiredb-crdt-kv&#34;,
		DataSyncChannel:     &#34;icefiredb-crdt-kv-data&#34;,
		NetDiscoveryChannel: &#34;icefiredb-crdt-kv-net&#34;,
		Namespace:           &#34;test&#34;,
		Logger:              log,
	})
	if err != nil {
		panic(err)
	}

	defer db.Close()

	fmt.Printf(&#34;&gt; &#34;)
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		text := scanner.Text()
		fields := strings.Fields(text)
		if len(fields) == 0 {
			fmt.Printf(&#34;&gt; &#34;)
			continue
		}

		cmd := fields[0]
		switch cmd {
		case &#34;exit&#34;, &#34;quit&#34;:
			return
		case &#34;get&#34;:
			if len(fields) &lt; 2 {
				printVal(&#34;missing key&#34;)
				continue
			}
			val, err := db.Get(ctx, []byte(fields[1]))
			if err != nil {
				printVal(err)
				continue
			}
			printVal(string(val))
		case &#34;put&#34;:
			if len(fields) &lt; 3 {
				printVal(&#34;Missing parameters&#34;)
				continue
			}

			printVal(db.Put(ctx, []byte(fields[1]), []byte(fields[2])))
		case &#34;delete&#34;:
			if len(fields) &lt; 2 {
				printVal(&#34;missing key&#34;)
				continue
			}
			printVal(db.Delete(ctx, []byte(fields[1])))
		case &#34;has&#34;:
			if len(fields) &lt; 2 {
				printVal(&#34;missing key&#34;)
				continue
			}
			is, err := db.Has(ctx, []byte(fields[1]))
			if err != nil {
				printVal(err)
				continue
			}
			printVal(is)
		case &#34;list&#34;:
			result, err := db.Query(ctx, query.Query{})
			if err != nil {
				printVal(err)
				continue
			}
			for val := range result.Next() {
				fmt.Printf(fmt.Sprintf(&#34;%s =&gt; %v\n&#34;, val.Key, string(val.Value)))
			}
			fmt.Print(&#34;&gt; &#34;)
		case &#34;query&#34;:
			if len(fields) &lt; 2 {
				printVal(&#34;missing query condition&#34;)
				continue
			}
			//fmt.Println(fields[1], len(fields[1]))
			q := query.Query{
				//Prefix: fields[1],
				Filters: []query.Filter{
					query.FilterKeyPrefix{
						Prefix: fields[1],
					},
				},
			}
			result, err := db.Query(ctx, q)
			if err != nil {
				printVal(err)
				continue
			}
			//time.Sleep(time.Second)
			for val := range result.Next() {
				fmt.Printf(fmt.Sprintf(&#34;%s =&gt; %v\n&#34;, val.Key, string(val.Value)))
			}
			fmt.Print(&#34;&gt; &#34;)

		case &#34;connect&#34;: // 主动连接
			if len(fields) &lt; 2 {
				printVal(&#34;Missing connection address&#34;)
				continue
			}
			err = db.Connect(fields[1])
			if err == nil {
				printVal(&#34;connection succeeded!&#34;)
			} else {
				printVal(err)
			}
		case &#34;slist&#34;:
			result, err := db.Store().Query(ctx, query.Query{})
			if err != nil {
				printVal(err)
				continue
			}
			for val := range result.Next() {
				fmt.Printf(fmt.Sprintf(&#34;%s =&gt; %v\n&#34;, val.Key, string(val.Value)))
			}
			fmt.Print(&#34;&gt; &#34;)
		case &#34;bquery&#34;:
			if len(fields) &lt; 2 {
				printVal(&#34;missing query condition&#34;)
				continue
			}
			db.DB().View(func(txn *badger2.Txn) error {
				opts := badger2.DefaultIteratorOptions
				opts.PrefetchSize = 10
				it := txn.NewIterator(opts)
				defer it.Close()
				prefix := []byte(fields[1])
				for it.Seek(prefix); it.ValidForPrefix(prefix); it.Next() {
					item := it.Item()
					k := item.Key()
					err := item.Value(func(v []byte) error {
						fmt.Printf(&#34;key=%s, value=%s\n&#34;, k, v)
						return nil
					})
					if err != nil {
						return err
					}
				}
				return nil
			})

		case &#34;blist&#34;:
			db.DB().View(func(txn *badger2.Txn) error {
				opts := badger2.DefaultIteratorOptions
				opts.PrefetchSize = 10
				it := txn.NewIterator(opts)
				defer it.Close()
				for it.Rewind(); it.Valid(); it.Next() {
					item := it.Item()
					k := item.Key()
					err := item.Value(func(v []byte) error {
						fmt.Printf(&#34;key=%s, value=%s\n&#34;, k, v)
						return nil
					})
					if err != nil {
						return err
					}
				}
				return nil
			})
		default:
			printVal(&#34;&#34;)
		}
	}
}

func printVal(v interface{}) {
	fmt.Printf(&#34;%v\n&gt; &#34;, v)
}
</code></pre><h2 id=roadmap>RoadMap
<a class=anchor href=#roadmap>#</a></h2><ol><li>Optimize project structure.</li><li>Encapsulates the kv engine layer for easy reference by upper-layer applications.</li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#project-introduction>Project introduction</a></li><li><a href=#features>Features</a></li><li><a href=#installing>Installing</a></li><li><a href=#example>Example</a></li><li><a href=#roadmap>RoadMap</a></li></ul></nav></div></aside></main></body></html>